# generator.py
# by Preston Hager
# for Aurora Compiler

class Generator:
    def __init__(self, parser):
        """
        Creates a new Generator instance

        Parameters
        ----------
        parser : Parser
            Parser to link to the generator

        Returns
        -------
        Generator
            New Generator instance with previous parameters.
        """
        self.parser = parser
        self.constants = {"string": {}, "number": {}}
        self.generated_code = "; generated by Aurora Compiler by Preston Hager\n; https://github.com/PrestonHager/AuroraCompiler\n[BITS 32]\n\n"
        self.generated_code_end = ""

    def generate(self):
        """
        Generates new code from the parser's AST
        """
        for node in self.parser.ast.children:
            generated_code_tuple = self._generate(node)
            if len(generated_code_tuple[0]) > 1:
                self.generated_code += generated_code_tuple[0]
            if len(generated_code_tuple[1]) > 1:
                self.generated_code_end += generated_code_tuple[1]
        self.generated_code += "\n" + self.generated_code_end.strip()

    def _generate(self, node):
        generated = ""
        generated_end = ""
        if node.name == "COMMENT":
            generated += f"; {node.children[0].value.strip()}"
        if node.name == "FUNCTION":
            children_dict = self._children_dictionary(node)
            name = children_dict["NAME"].value
            arguments = children_dict["ARGUMENTS"].children
            if name == "include":
                type = arguments[0]
                if type.name == "STRING":
                    file = arguments[0].value
                else:
                    file = "_aurora_" + arguments[0].value
                generated_end += f"%include \"{file}\"\n"
            elif name == "_asm":
                for argument in arguments:
                    if argument.name == "STRING":
                        generated += f"{argument.value}\n"
            else:
                generated += f"; Arguments: {arguments}\n"
                for argument in arguments:
                    if argument.name == "STRING":
                        var, new = self._constant("string", argument.value)
                        generated += f"mov [_aurora_arg_buffer], _aurora_string_{var}\n"
                        if new:
                            generated_end += f"_aurora_string_{var} db \"{argument.value}\", 0\n"
                    if argument.name == "NUMBER":
                        var, new = self._constant("number", argument.value)
                        generated += f"mov [_aurora_arg_buffer], _aurora_number_{var}\n"
                        if new:
                            generated_end += f"_aurora_number_{var} dq {argument.value}\n"
                generated += f"call {name}"
        return (generated.strip()+"\n", generated_end.strip()+"\n")

    def _children_dictionary(self, node):
        children_dictionary = {}
        for child in node.children:
            children_dictionary[child.name] = child
        return children_dictionary

    def _constant(self, type, value):
        new = False
        if value not in self.constants[type]:
            new = True
            if len(self.constants[type]) < 1:
                self.constants[type][value] = 0
            else:
                self.constants[type][value] = max(self.constants[type].values())+1
        return (self.constants[type][value], new)
