# generator.py
# by Preston Hager
# for Aurora Compiler

from math import ceil
from utils.constants import COMPARISON_INSTRUCTIONS

class Generator:
    def __init__(self, parser, compiler_uuid, is_dependency=False):
        """
        Creates a new Generator instance

        Parameters
        ----------
        parser : Parser
            Parser to link to the generator

        Returns
        -------
        Generator
            New Generator instance with previous parameters.
        """
        self.uuid = compiler_uuid
        # Some important variables:
        # First, the parser linked to the generator.
        self.parser = parser
        # The next two are for keeping track of what "labels" or "variables" we've defined so far.
        self.constants = {"string": {}, "number": {}}
        self.variables = {"string": [], "number": []}
        # A loop variable increased every time a loop is generated.
        self.loop_number = -1
        # The actual code is stored in these.
        self.generated_code = f"; generated by Aurora Compiler by Preston Hager\n; https://github.com/PrestonHager/AuroraCompiler\n; UUID: {self.uuid}\n[BITS 32]\n\n"
        if is_dependency:
            self.generated_code_end = ""
        else:
            self.generated_code_end = f"_aurora_arg_buffer times 32 dq 0\n"

    def generate(self):
        """
        Generates new code from the parser's AST
        """
        # Loop over each node in the AST and generate assembly code for it.
        for node in self.parser.ast.children:
            # The generated code is in two places, the normal spot, and the end.
            generated_code_tuple = self._generate(node)
            if len(generated_code_tuple[0]) > 1:
                self.generated_code += generated_code_tuple[0]
            if len(generated_code_tuple[1]) > 1:
                self.generated_code_end += generated_code_tuple[1]
        # Add all the end generated code to the main string of code.
        self.generated_code += "\n" + self.generated_code_end.strip()

    def _generate(self, node):
        # Generate the actual code for each node.
        # Note to self: I use actual too much, I have too many nested functions, welcome to Python.
        generated = ""
        generated_end = ""
        # Test for the `COMMNET` node, this can just be translated as a comment.
        if node.name == "COMMENT":
            generated += f"; {node.children[0].value.strip()}"
        # Test for the `FUNCTION` node.
        elif node.name == "FUNCTION":
            # First we get the name and arguments of the function.
            children_dict = self._children_dictionary(node)
            name = children_dict["NAME"].value
            arguments = children_dict["ARGUMENTS"].children
            # The code for an `_asm` function is a bit different.
            # TODO: Move this code to the parser where it belongs.
            if name == "_asm":
                for argument in arguments:
                    if argument.name == "STRING":
                        generated += f"{argument.value}\n"
            # Otherwise, we treat it as a normal function.
            else:
                generated += f"; Arguments: {arguments}\n"
                arg_number = 0
                for argument in arguments:
                    arg_number += 1
                    if argument.name == "STRING":
                        var, new = self._constant("string", argument.value)
                        generated += f"mov [_aurora_arg_buffer+{arg_number*4}], DWORD _aurora_{self.uuid}_string_{var}\n"
                        if new:
                            generated_end += f"_aurora_{self.uuid}_string_{var} db \"{argument.value}\", 0\n"
                    elif argument.name == "NUMBER":
                        var, new = self._constant("number", argument.value)
                        generated += f"mov [_aurora_arg_buffer+{arg_number*4}], DWORD _aurora_{self.uuid}_number_{var}\n"
                        if new:
                            generated_end += f"_aurora_{self.uuid}_number_{var} dd {argument.value}\n"
                    elif argument.name == "VARIABLE":
                        generated += f"mov [_aurora_arg_buffer+{arg_number*4}], DWORD _{self.uuid}_{argument.value}\n"
                generated += f"call {name}"
        elif node.name == "FOR":
            children_dict = self._children_dictionary(node)
            initialization = children_dict["INITIALIZATION"].children[0]
            condition = children_dict["CONDITION"].children[0]
            loop = children_dict["LOOP"].children[0]
            code = children_dict["CODE"].children
            self.loop_number += 1
            # generate the label and initialization parts.
            gen_init = self._generate(initialization)
            generated += f"_aurora_{self.uuid}_loop_{self.loop_number}:\n{gen_init[0].strip()}\n.start:\n"
            generated_end += gen_init[1].strip() + "\n"
            # generate code for each of the nodes.
            for n in code:
                gen_code = self._generate(n)
                generated += gen_code[0].strip() + "\n"
                generated_end += gen_code[1].strip() + "\n"
            # generated the increase (loop), and condition parts.
            generated += self._generate_compare(condition, ".end_loop")
            gen_loop = self._generate(loop)
            generated += f"{gen_loop[0].strip()}\n"
            generated_end += gen_loop[1].strip() + "\n"
            generated += "jmp .start\n.end_loop:\n"
        elif node.name == "VARIABLE_DEFINITION":
            children_dict = self._children_dictionary(node)
            type = children_dict["TYPE"].value
            name = children_dict["NAME"].value
            if type == "STRING":
                value = children_dict["VALUE"].children[0].children[0].value
                self.variables["string"].append(name)
                generated_end += f"_{self.uuid}_{name} db \"{value}\", 0"
            elif type == "NUMBER":
                value = self._generate_value(children_dict["VALUE"].children[0])
                gen_value = value
                generated += f"{gen_value[0].strip()}\nmov [_{self.uuid}_{name}], eax\n"
                generated_end == gen_value[1]
                if name not in self.variables["number"]:
                    self.variables["number"].append(name)
                    generated_end += f"_{self.uuid}_{name} dd 0\n"
        elif node.name == "FUNCTION_DEFINTION":
            children_dict = self._children_dictionary(node)
            name = children_dict["NAME"].value
            parameters = children_dict["PARAMETERS"].children
            code = children_dict["CODE"].children
            generated += f"; {name}: {parameters}\n{name}:\n\tpusha\n"
            for line in code:
                generated_line = self._generate(line)
                generated += "\t" + "\n\t".join(generated_line[0].split("\n")).strip() + "\n"
                generated_end += generated_line[1]
            generated += f"\t.done:\n\tpopa\n\tret\n"
        elif node.name == "VARIABLE_ASSIGNMENT":
            children_dict = self._children_dictionary(node)
            variable_dict = self._children_dictionary(children_dict["VARIABLE"])
            name = variable_dict["NAME"].value
            size = children_dict["SIZE"].value
            value = self._generate_value(children_dict["VALUE"].children[0])
            generated += value[0].strip() + "\n"
            generated_end += value[1].strip() + "\n"
            if variable_dict["POINTER"].value:
                generated += f"mov edx, [_{self.uuid}_{name}]\nmov [edx], {self._generate_register('a', size)}\n"
            else:
                generated += f"mov [_{self.uuid}_{name}], {self._generate_register('a', size)}\n"
        elif node.name == "INCLUDE":
            children_dict = self._children_dictionary(node)
            generated_end += f"%include \"{children_dict['FILE'].value}\"\n"
        return (generated.strip()+"\n", generated_end.strip()+"\n")

    def _generate_compare(self, compare, label):
        generated = "\n"
        children_dict = self._children_dictionary(compare)
        value1 = self._generate_value(children_dict["VALUE_1"].children[0])
        value2 = self._generate_value(children_dict["VALUE_2"].children[0])
        generated += f"{value1[0].strip()}\nmov ecx, eax\n{value2[0].strip()}\ncmp eax, ecx\n"
        generated += COMPARISON_INSTRUCTIONS[children_dict["TEST"].value] + " " + label + "\n"
        return generated

    def _generate_value(self, postfix):
        value = ""
        generated_end = ""
        number_stack = []
        for node in postfix.children:
            if node.name == "NUMBER" or node.name == "VARIABLE" or node.name == "FUNCTION":
                number_stack.append(node)
            else:
                if value == "":
                    gen_var = self._generate_variable(number_stack.pop())
                    generated_end += gen_var[1]
                    value += f"mov eax, {gen_var[0]}\n"
                if node.name == "TIMES":
                    last_number = number_stack.pop()
                    gen_var = self._generate_variable(last_number)
                    if last_number.name == "FUNCTION":
                        generated_end += gen_var[1]
                    value += f"mov ebx, {gen_var[0]}\nmul ebx\n"
                elif node.name == "DIVIDE":
                    last_number = number_stack.pop()
                    gen_var = self._generate_variable(last_number)
                    if last_number.name == "FUNCTION":
                        generated_end += gen_var[1]
                    value += f"mov ebx, {gen_var[0]}\n"
                elif node.name == "PLUS":
                    last_number = number_stack.pop()
                    gen_var = self._generate_variable(last_number)
                    if last_number.name == "FUNCTION":
                        generated_end += gen_var[1]
                    value += f"mov ebx, {gen_var[0]}\nadd eax, ebx\n"
                elif node.name == "MINUS":
                    last_number = number_stack.pop()
                    gen_var = self._generate_variable(last_number)
                    if last_number.name == "FUNCTION":
                        generated_end += gen_var[1]
                    value += f"mov ebx, {gen_var[0]}\nsub eax, ebx\n"
        if value == "" and len(number_stack) > 0:
            gen_var = self._generate_variable(number_stack.pop())
            if gen_var[2]:
                value += gen_var[0] + "\n"
            else:
                value += f"mov eax, {gen_var[0]}\n"
            generated_end += gen_var[1]
        return (value, generated_end)

    def _generate_variable(self, variable):
        if variable.name == "VARIABLE":
            if variable.name in self.variables["number"]:
                return (f"[_{self.uuid}_{variable.value}]", f"_{self.uuid}_{variable.value} dd 0\n", False)
            return (f"[_{self.uuid}_{variable.value}]", "", False)
        elif variable.name == "NUMBER":
            return (f"{variable.value}", "", False)
        elif variable.name == "FUNCTION":
            return self._generate(variable) + (True,)
        else:
            raise ValueError

    def _generate_register(self, register, size="DOUBLE_WORD"):
        if size == "DOUBLE_WORD":
            if register in ["a", "b", "c", "d"]:
                return "e"+register+"x"
            elif register in ["si", "sp", "ds", "cs", "es"]:
                return "e"+register
        elif size == "WORD":
            if register in ["a", "b", "c", "d"]:
                return register+"x"
            elif register in ["si", "sp", "ds", "cs", "es"]:
                return register
        elif size == "BYTE":
            if register in ["a", "b", "c", "d"]:
                return register+"l"
            elif register in ["si", "sp", "ds", "cs", "es"]:
                raise ValueError

    def _children_dictionary(self, node):
        children_dictionary = {}
        for child in node.children:
            children_dictionary[child.name] = child
        return children_dictionary

    def _constant(self, type, value):
        new = False
        if value not in self.constants[type]:
            new = True
            if len(self.constants[type]) < 1:
                self.constants[type][value] = 0
            else:
                self.constants[type][value] = max(self.constants[type].values())+1
        return (self.constants[type][value], new)
