Parser
======

What does this do?
~~~~~~~~~~~~~~~~~~

The Parser takes the array (list) of tokens generated by the Lexer and
turns it into an Abtract Syntax Tree (AST). An AST is a visual
representation of how code generation might be completed. This means it
takes the ordered list of tokens and turns it into something a Generator
can understand and create code out of.

Input & Output
^^^^^^^^^^^^^^

The input is a list of tokens generated by the Lexer. These tokens can
also be displayed in a human-friendly format of a table. The output is an
Abstract Syntax Tree (AST), in the json format. The following is an example
of input and ouput of the Parser.

Input:

+-------------------+-------------------------------+-----------+
| Token ID          | Token Value                   | Position  |
+===================+===============================+===========+
| ID                | print                         | 1, 1      |
+-------------------+-------------------------------+-----------+
| FUNC              | >                             | 6, 1      |
+-------------------+-------------------------------+-----------+
| STRING_DEF        | "                             | 7, 1      |
+-------------------+-------------------------------+-----------+
| ID                | Somewhere over the rainbow!   | 8, 1      |
+-------------------+-------------------------------+-----------+
| END_STRING_DEF    | "                             | 14, 1     |
+-------------------+-------------------------------+-----------+
| ENDLINE           | ;                             | 15, 1     |
+-------------------+-------------------------------+-----------+

Output:

.. code::

    {"body": [
        {
        "token_type": "function",
        "token_value": "print",
        "children": [
            {
                "token_type": "string",
                "token_value": "Hello!",
                "children": []
            }]
        }
    ]}

Timeline?
~~~~~~~~~

-  **Day 1:** Create 1-2 example ASTs and companion code. Then write
   psuedo code for how it might execute.
-  **Day 2:** Finish up the psuedo code. Then start on writing actual
   Python code.
-  **Day 3:** Complete actual Python code, and then polish and squash
   those bugs!